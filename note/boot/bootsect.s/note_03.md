# 基础的准备工作
```
go: mov ax,cs
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov sp,#0xFF00
```
把`cs`寄存器的数值分别复制给`ds`、`es`和`ss`寄存器，然后把`0xFF00`给了`sp`寄存器
- `cs`寄存器代表`代码段寄存器`，CPU当前正在执行在内存中的位置，就是由`cs:ip`这组寄存器配合指向的，`cs`是基址，`ip`是偏移地址
    > `jmpi go,0x9000`
    - 此时`cs`中为`0x9000`，`ip`中是`go`这个标签的偏移地址
    - `ds`、`es`和`ss`寄存器都赋值为`0x9000`
	- `ds数据段寄存器`：代码挪到`0x9000`所以`ds`也被同样赋值
	- `es拓展段寄存器`
	- `ss栈段寄存器`：配合`栈基址寄存器sp`来表示此时的栈顶地址
	    - 此时`sp`为`0xFF00`，所以目前的栈顶地址就是`ss:sp`所指向的地址`0x9FF00`处

## 总结
1. 代码从硬盘移到内存又从内存挪个位置放在`0x9000`处
2. `数据段寄存器ds`和`代码段寄存器cs`此时都为`0x9000`，为跳转代码和访问内存数据，奠定了同一个内存的基址地址，在这之后跳转和内存访问变得方便，仅仅需要指定偏移地址即可
3. 栈顶地址设置为了`0x9FF00`（通过ss和sp定义），栈是向下发展，栈顶地址足够大，所以也不会很容易撞倒代码
4. 总的来说，操作系统给如何访问代码，如何访问数据，如何访问栈进行了一下`内存的初步规划`。其中访问代码和访问数据的规划方式就是设置了一个`基址`，访问栈也只是把`栈顶指针`指向一个远离代码位置

